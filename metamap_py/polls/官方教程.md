####  安装
```
pip install Django
```

#### 第一个ap
```
django-admin startproject mysite
```
会生成一个目录
```
mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        wsgi.py
```
- manage.py。 用来操作django项目的命令行工具。参考[django-admin and manage.py.](https://docs.djangoproject.com/en/1.9/ref/django-admin/)
-  里面的mysite目录是真正的项目目录。
-  mysite/__init__.py。只是说明这是一个python package。
-  mysite/settings.py: 项目的配置文件，参考[Django settings](https://docs.djangoproject.com/en/1.9/topics/settings/)
-  mysite/urls.py:描述django项目的路由。参看[URL dispatcher](https://docs.djangoproject.com/en/1.9/topics/http/urls/)
-  mysite/wsgi.py: An entry-point for WSGI-compatible web servers to serve your project. See [How to deploy with WSGI for more details](https://docs.djangoproject.com/en/1.9/howto/deployment/wsgi/).


#### 运行
```
python manage.py runserver 0.0.0.0:8000
```
默认端口是8000，且只允许单机自己访问。

#### 创建polls应用
上面是创建了project，下面我们要创建的是app。一个project可以包含多个app，一个app也可以属于多个project。

你的app可以在任何地方，只要在[python path](https://docs.python.org/3/tutorial/modules.html#tut-searchpath)上就行。这个简单教程里，就直接在当前project下创建app了。

```
python manage.py startapp polls
```
结果如下：
```
polls/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py
```

#### 写一个view
编写polls/views.py
```python
from django.http import HttpResponse


def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")
```
为当前app创建路由文件polls/urls.py
```python
from django.conf.urls import url

from . import views

urlpatterns = [
    url(r'^$', views.index, name='index'),
]
```
下一步就是让project和app直接建立联系，通过urls。编辑project下的urls.py
```python
from django.conf.urls import include, url
from django.contrib import admin

urlpatterns = [
    url(r'^polls/', include('polls.urls')),
    url(r'^admin/', admin.site.urls),
]
```
include方法引用了polls app的urls。有了include我们的urls文件就可以放在任意路径了。
重启server，访问http://localhost:8000/polls/ 就可以看到我们view里的内容了。
```
python manage.py runserver
```
url()函数接收4个参数，两个是必备的：regex和view，还有kwargs和name作为可选项。


#### 设置数据库
编辑`mysite/settings.py`，默认是SQLite。相关关键词是`ENGINE`，由于这是个起步学习项目，暂时就用默认的吧。

在使用之前，我们需要为数据库准备一些东西。
```
python manage.py migrate
```
`migrate`命令会找 `mysite/settings.py`里的INSTALLED_APPS，找到后根据配置创建相应的数据表。

#### 创建model
这个app里我们需要创建俩个model：`Question` 和 `Choice`。
编辑`polls/models.py`文件
```python
from django.db import models


class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')


class Choice(models.Model):
    # 外键
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
```


#### 激活model
model给了django很多的便捷：
- 创建数据表
- 创建访问model数据的api

但是首先我们应该先挂载这个app。再次编辑`mysite/settings.py`，修改`INSTALLED_APPS `,设置`'polls.apps.PollsConfig'`属性：
```python
INSTALLED_APPS = [
    'polls.apps.PollsConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```
这样就把polls挂载上了。然后执行下面的命令：
```
root@will-vm:/usr/local/metamap/metamap_py# python manage.py makemigrations polls
Migrations for 'polls':
  0001_initial.py:
    - Create model Choice
    - Create model Question
    - Add field question to choice
```
通过执行`makemigrations`命令，你可以告诉django你已经对model进行了修改，需要将这些修改保存起来作为一次`migration`。

`migration`记录了django怎样修改的你的数据表，都是些硬盘上的文件，可以直接打开看。上面的步骤中就生成了`polls/migrations/0001_initial.py`文件。我们不必总关心这些文件，这些文件主要是当我们想弄一些定制化的操作的时候方便手动修改。

`migrate`命令用来自动将migration里生成的数据修改操作执行完毕。在此之前，我们先使用`sqlmigrate`命令查看一下migration生成的sql是怎样的：
```
root@will-vm:/usr/local/metamap/metamap_py# python manage.py sqlmigrate polls 0001
BEGIN;
--
-- Create model Choice
--
CREATE TABLE "polls_choice" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "choice_text" varchar(200) NOT NULL, "votes" integer NOT NULL);
--
-- Create model Question
--
CREATE TABLE "polls_question" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "question_text" varchar(200) NOT NULL, "pub_date" datetime NOT NULL);
--
-- Add field question to choice
--
ALTER TABLE "polls_choice" RENAME TO "polls_choice__old";
CREATE TABLE "polls_choice" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "choice_text" varchar(200) NOT NULL, "votes" integer NOT NULL, "question_id" integer NOT NULL REFERENCES "polls_question" ("id"));
INSERT INTO "polls_choice" ("choice_text", "votes", "id", "question_id") SELECT "choice_text", "votes", "id", NULL FROM "polls_choice__old";
DROP TABLE "polls_choice__old";
CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");

COMMIT;

```
注意以下几点：
- 输出的sql根据你选择的engine不同而不同，上面是SQLite的
- 表名字是使用app名字和model名字小写自动拼成的
- 主键自动生成。不合适的话可自己定制
- 为方便区分，django会在外键的后面缀上`_id`
- `sqlmigrate`命令并不实际执行这些sql，只是输出而已

详情参照[python manage.py check](https://docs.djangoproject.com/en/1.9/ref/django-admin/#django-admin-check),这个命令检查你的项目中存在的问题，而且不会对你的数据库有任何影响。

好了，运行`migrate`命令，在你的DB里创建对应的表结构吧：
```
root@will-vm:/usr/local/metamap/metamap_py# python manage.py migrate
Operations to perform:
  Apply all migrations: admin, contenttypes, polls, auth, sessions
Running migrations:
  Rendering model states... DONE
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying polls.0001_initial... OK
  Applying sessions.0001_initial... OK

```
有了`Migrations `,你只需要专心开发你的项目就可以了，不用总是来操作数据库。后面我们会详细介绍，现在咱们总结一下创建或者修改model的三个步骤：
 - 在`models`里修改你的model
 - 运行` python manage.py makemigrations`创建migration
 - 运行`python manage.py migrate `将migration应用到你的db
 
之所以要分这么多步骤，主要是可以自己中间定制这些migration，完事儿上传到git上去。不仅仅是开发方便，对于其他的开发人员也很有用。

对于`manage.py`的详细用法，参照[django-admin documentation ](https://docs.djangoproject.com/en/1.9/ref/django-admin/)


#### 玩玩API
启动
```
python manage.py shell
```
这个命令相对于直接使用`python`的REPL来说，设置了`DJANGO_SETTINGS_MODULE`环境变量，这个变量指明了` mysite/settings.py`文件的python path。

必须在manage.py所在的目录下才行，或者在python path所在的目录，这样import mysite才能起作用。

```python
>>> from polls.models import Question, Choice
>>> Question.objects.all()
[]
>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())
>>> q.save()
>>> q.id
1
>>> q.question_text
"What's new?"
>>> q.pub_date
datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=<UTC>)

# 修改属性后保存
>>> q.question_text = "What's up?"
>>> q.save()

>>> Question.objects.all()
[<Question: Question object>]
```
可以看到，查询所有的Question的时候，打印出来的东西`<Question: Question object>`并不可读。我们可以在`models`里的`Question`和`Choice`模型添加`__str__()`方法。

```python
polls/models.py
from django.db import models
from django.utils.encoding import python_2_unicode_compatible

@python_2_unicode_compatible  # only if you need to support Python 2
class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text

@python_2_unicode_compatible  # only if you need to support Python 2
class Choice(models.Model):
    # ...
    def __str__(self):
        return self.choice_text
```

另外django还有一些自动生成的对于model的方便操作的方法。我们也可以定义自己的方法
```python
import datetime

from django.db import models
from django.utils import timezone


class Question(models.Model):
    # ...
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
```
完事儿把上面的修改验证一下：

```python
>>> from polls.models import Question, Choice

# 验证__str__()
>>> Question.objects.all()
[<Question: What's up?>]

# Django 提供了丰富的查找db的api.
>>> Question.objects.filter(id=1)
[<Question: What's up?>]
>>> Question.objects.filter(question_text__startswith='What')
[<Question: What's up?>]
>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)
<Question: What's up?>

# 找不到记录的时候会抛出一个exception.
>>> Question.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Question matching query does not exist.

# 按照主键查找
>>> Question.objects.get(pk=1)
<Question: What's up?>

# 确认我们自定义的方法有效
>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()
True

# 为question创建点Choice，然后操作这些Choice对象。
>>> q = Question.objects.get(pk=1)
>>> q.choice_set.all()
[]
>>> q.choice_set.create(choice_text='Not much', votes=0)
<Choice: Not much>
>>> q.choice_set.create(choice_text='The sky', votes=0)
<Choice: The sky>
>>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)
>>> c.question
<Question: What's up?>
>>> q.choice_set.all()
[<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]
>>> q.choice_set.count()
3
>>> Choice.objects.filter(question__pub_date__year=current_year)
[<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]
>>> c = q.choice_set.filter(choice_text__startswith='Just hacking')
>>> c.delete()
>>> q.choice_set.all()
[<Choice: Not much>, <Choice: The sky>]
```

#### Django Admin

一些用户以及内容管理的功能是基本必备的，也没有什么可创新的，django为你准备好了这些。网站管理者使用它管理网站内容，发布给访问者看。

y面向网站管理者，而不是网站访问者。

创建一个admin用户
```
root@will-vm:/usr/local/metamap/metamap_py# python manage.py createsuperuser
Username (leave blank to use 'root'): admin
Error: Enter a valid email address.
Email address: will@163.com
Password: 
Password (again): 
This password is too short. It must contain at least 8 characters.
This password is too common.
Password: 
Password (again): 
Superuser created successfully.

```
然后启动server，到` http://127.0.0.1:8000/admin/`登录进入管理页面。
![初始admin主界面](https://docs.djangoproject.com/en/1.9/_images/admin02.png)

这时我们并看不到polls，需要编辑`polls/admin.py`文件，使polls能够被修改才行：
```python
from django.contrib import admin

from .models import Question

admin.site.register(Question)
```
完成后，刷新一下页面
![初始admin主界面](https://docs.djangoproject.com/en/1.9/_images/admin03t.png)
点击Question，调到的页面列出了数据库中所有的Question对象，而且可以点击任意一个进行编辑修改。
![](https://docs.djangoproject.com/en/1.9/_images/admin04t.png)

修改
![](https://docs.djangoproject.com/en/1.9/_images/admin05t.png)

这里注意以下几点：
 - 这个form是根据Question model自动生成的
 - 不同的字段类型会自动对应于form中不同的input类型
 - 每个` DateTimeField `都会被自动格式化

如果Date published跟你在前面自己设置的不吻合，有可能是[`TIME_ZONE `](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TIME_ZONE)没有设置正确。

被修改的历史，可以点击单条记录页面右上角的`History`
![](https://docs.djangoproject.com/en/1.9/_images/admin06t.png)

我们还可以把界面弄的更高级一些
```python
from django.contrib import admin

from .models import Choice, Question


class ChoiceInline(admin.StackedInline):
    model = Choice
    extra = 3


class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
    ]
    inlines = [ChoiceInline]
    list_display = ('question_text', 'pub_date', 'was_published_recently')
    list_filter = ['pub_date']

admin.site.register(Question, QuestionAdmin)
```

使用QuestionAdmin对Question里的属性进行了分组与组内排序，把Choice引入进来。

![](https://docs.djangoproject.com/en/1.9/_images/admin10t.png)

另外我们使用`list_display`也微调了一下列表页显示的字段，还使用`list_filter`添加了一个对于pub_date的过滤器，注意这可是数组哦。
![](https://docs.djangoproject.com/en/1.9/_images/admin13t.png)

[更多内容](https://docs.djangoproject.com/en/1.9/intro/tutorial07/)



views
---
模板与变量的结合体。对于polls应用，有以下几个view
 - Question “index”页面 —— 展示最新的几个Question
 - Question “detail”
 - Question “results”  —— 展示问题的结果
 - 投票动作。为Quesion下的某个choice投票。
 
django会根据URL的匹配信息来决定使用哪个view。参考[ django.core.urlresolvers](https://docs.djangoproject.com/en/1.9/ref/urlresolvers/#module-django.core.urlresolvers)

我们往` polls/views.py`里写几个view：
```python
def detail(request, question_id):
    return HttpResponse("You're looking at question %s." % question_id)

def results(request, question_id):
    response = "You're looking at the results of question %s."
    return HttpResponse(response % question_id)

def vote(request, question_id):
    return HttpResponse("You're voting on question %s." % question_id)
```

把对应的url添加到`polls/urls.py`里：
```python
from django.conf.urls import url

from . import views

urlpatterns = [
    # ex: /polls/
    url(r'^$', views.index, name='index'),
    # ex: /polls/5/
    url(r'^(?P<question_id>[0-9]+)/$', views.detail, name='detail'),
    # ex: /polls/5/results/
    url(r'^(?P<question_id>[0-9]+)/results/$', views.results, name='results'),
    # ex: /polls/5/vote/
    url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),
]
```
假设请求“/polls/34/”，请求会经过[` ROOT_URLCONF`](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-ROOT_URLCONF), 也就是`mysite.urls`,找到`polls.urls`，再找到views.detail，调用`detail(request=<HttpRequest object>, question_id='34')`方法。

##### 让view操练起来

编辑polls/views.py里的index view
```python
from django.http import HttpResponse

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    output = ', '.join([q.question_text for q in latest_question_list])
    return HttpResponse(output)
```

这里有个问题，页面布局是硬编码的。每次改页面布局的话都得修改python代码。是时候让模板露面了。

到polls下创建`templates`文件夹。你对于[ TEMPLATES](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-TEMPLATES)的设置会告诉django怎样加载并渲染你的template。默认是使用的`DjangoTemplates `,它会找每个app下面的templates文件夹。

在你刚才创建的`templates`下再创建一个`polls`文件夹，在这个文件夹下创建`index.html`文件，就是` polls/templates/polls/index.html`。
```html
{% if latest_question_list %}
    <ul>
    {% for question in latest_question_list %}
        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}
```

修改view使用这个template：
```python
from django.http import HttpResponse
from django.template import loader

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    template = loader.get_template('polls/index.html')
    context = {
        'latest_question_list': latest_question_list,
    }
    return HttpResponse(template.render(context, request))
```
这段代码是加载template，并传递给它一个context，这个`Context`里放置着template与view变量命名的映射。

也可以写成
```python
from django.shortcuts import render

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]
    context = {'latest_question_list': latest_question_list}
    return render(request, 'polls/index.html', context)
```
就不用import  `loader` 和 `HttpResponse`,返回的是一个已经渲染好的`HttpResponse`对象。

###### 错误404

当访问一个不存在的Question的时候，就应该友好地提示。修改`polls/views.py`
```python
from django.http import Http404
from django.shortcuts import render

from .models import Question
# ...
def detail(request, question_id):
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404("Question does not exist")
    return render(request, 'polls/detail.html', {'question': question})
```
创建模板文件polls/templates/polls/detail.html
```html
{{ question }}
```

404这个也有简写：
```python
from django.shortcuts import get_object_or_404, render

from .models import Question
# ...
def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/detail.html', {'question': question})
```

模板也支持流程控制：
```html
<h1>{{ question.question_text }}</h1>
<ul>
{% for choice in question.choice_set.all %}
    <li>{{ choice.choice_text }}</li>
{% endfor %}
</ul>
```

##### url命名空间
当app多了的时候，就需要在每个app自己的url里添加`app_name`属性。
```python
from django.conf.urls import url

from . import views

app_name = 'polls'
urlpatterns = [
    url(r'^$', views.index, name='index'),
    url(r'^(?P<question_id>[0-9]+)/$', views.detail, name='detail'),
    url(r'^(?P<question_id>[0-9]+)/results/$', views.results, name='results'),
    url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),
]
```
然后在views里写链接的时候，加上这个前缀
```html
<li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>
```



#### form表单
进一步修改detail.html模板
```html
<h1>{{ question.question_text }}</h1>

{% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}

<form action="{% url 'polls:vote' question.id %}" method="post">
{% csrf_token %}
{% for choice in question.choice_set.all %}
    <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}" />
    <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br />
{% endfor %}
<input type="submit" value="Vote" />
</form>
```
注意有个**`{% csrf_token %}`**,是django为了防止Cross Site Request Forgeries，所有请求内部URL的都加上这个东西。

在`polls/urls.py`里添加提交数据的路由。
```python
url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),
```

修改`polls/views.py`里的方法：
```python 
from django.shortcuts import get_object_or_404, render
from django.http import HttpResponseRedirect, HttpResponse
from django.core.urlresolvers import reverse

from .models import Choice, Question
# ...
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(request, 'polls/detail.html', {
            'question': question,
            'error_message': "You didn't select a choice.",
        })
    else:
        selected_choice.votes += 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))
        
def results(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/results.html', {'question': question})
```
可以看到存储成功后，重定向到了这个question的结果展示的路由。关于更多[request and response documentation](https://docs.djangoproject.com/en/1.9/ref/request-response/)

对了，还有一个result的template，创建文件`polls/results.html`
```html
<h1>{{ question.question_text }}</h1>

<ul>
{% for choice in question.choice_set.all %}
    <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
{% endfor %}
</ul>

<a href="{% url 'polls:detail' question.id %}">Vote again?</a>
```

**注意** ：这里的vote修改是有些并发问题 ` race condition `的，参照[ Avoiding race conditions using F() ](https://docs.djangoproject.com/en/1.9/ref/models/expressions/#avoiding-race-conditions-using-f)

###### 使用django的GenericView
回头看下detail和result的view都太简单了，index也差不多。django为这些简单又常用的view提供了一些简单的写法，叫`generic views`系统。

要使用`generic views`,需要2个步骤：
1. 修改URLconf
```python
from django.conf.urls import url

from . import views

app_name = 'polls'
urlpatterns = [
    url(r'^$', views.IndexView.as_view(), name='index'),
    url(r'^(?P<pk>[0-9]+)/$', views.DetailView.as_view(), name='detail'),
    url(r'^(?P<pk>[0-9]+)/results/$', views.ResultsView.as_view(), name='results'),
    url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),
]
```
注意，是把`<question_id>` 改成了 ` <pk>`.
2. 删除老的，不必要的view，使用Django的generic views.
```python
from django.shortcuts import get_object_or_404, render
from django.http import HttpResponseRedirect
from django.core.urlresolvers import reverse
from django.views import generic

from .models import Choice, Question


class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
        """Return the last five published questions."""
        return Question.objects.order_by('-pub_date')[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = 'polls/detail.html'


class ResultsView(generic.DetailView):
    model = Question
    template_name = 'polls/results.html'


def vote(request, question_id):
    ... # same as above, no changes needed.
```
使用了两个generic view： **ListView** 和 **DetailView**。

每个`generic view`都需要知道自己操作什么样的model。

**DetailView**需要主键才能正常抽取db里的数据并渲染，所以我们修改了urls里的questio_id为pk。

DetailView默认使用的模板文件是`<app name>/<model name>_detail.html`,这里就应该是`polls/question_detail.html`。如果不按这个规范走，那就在view里使用`template_name `写明对应template的地址。ListView同理。

`context_object_name `变量用来指定当前view传送到template使用的变量名。DetailView默认是model名称`question`,ListView默认是model_list：`question_list`。上面我们在list里使用了自己指定的变量名称。

更多内容，参考[generic views documentation](https://docs.djangoproject.com/en/1.9/topics/class-based-views/)


#### 自动化测试
创建一次test代码，后面你随意修改，都会自动进行测试，不用手动触发执行。

在`polls/tests.py`添加测试我们前面自定义方法was_published_recently是否正确运行：
```python
import datetime

from django.utils import timezone
from django.test import TestCase

from .models import Question


class QuestionMethodTests(TestCase):

    def test_was_published_recently_with_future_question(self):
        """
        was_published_recently() should return False for questions whose
        pub_date is in the future.
        """
        time = timezone.now() + datetime.timedelta(days=30)
        future_question = Question(pub_date=time)
        self.assertEqual(future_question.was_published_recently(), False)
```
运行测试
```
^Croot@will-vm:/usr/local/metamap/metamap_py# python manage.py test polls
Creating test database for alias 'default'...
F
======================================================================
FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionMethodTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/usr/local/metamap/metamap_py/polls/tests.py", line 18, in test_was_published_recently_with_future_question
    self.assertEqual(future_question.was_published_recently(), False)
AssertionError: True != False

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
Destroying test database for alias 'default'...
```

djang也可以通过shell运行测试：
```python
>>> from django.test.utils import setup_test_environment
# 这个方法会加载一个template render，这样我们就可以使用 response.context 获取到response中的属性。这个方法并不创建新的测试DB，后面的命令会直接运行在已有的数据上。
>>> setup_test_environment()
>>> from django.test import Client
>>> client = Client()
>>> # 请求 '/'
>>> response = client.get('/')
>>> # we should expect a 404 from that address
>>> response.status_code
404
>>> from django.core.urlresolvers import reverse
>>> response = client.get(reverse('polls:index'))
>>> response.status_code
200
>>> response.content
b'\n\n\n    <p>No polls are available.</p>\n\n'
>>> # 注意设置 ``TIME_ZONE``
>>> from polls.models import Question
>>> from django.utils import timezone
>>> # create a Question and save it
>>> q = Question(question_text="Who is your favorite Beatle?", pub_date=timezone.now())
>>> q.save()
>>> response = client.get('/polls/')
>>> response.content
b'\n\n\n    <ul>\n    \n        <li><a href="/polls/1/">Who is your favorite Beatle?</a></li>\n    \n    </ul>\n\n'
>>> response.context['latest_question_list']
[<Question: Who is your favorite Beatle?>]
```


再次改进view，让它能自己测试验证一些东西。从index下手，创建自己的`IndexView`，继承类`generic.ListView`：
```python
class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
        """
        Return the last five published questions (not including those set to be
        published in the future).
        """
        return Question.objects.filter(
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]
        
class DetailView(generic.DetailView):
    ...
    def get_queryset(self):
        """
        Excludes any questions that aren't published yet.
        """
        return Question.objects.filter(pub_date__lte=timezone.now())
```
我们需要修改一`get_queryset`方法，让他验证一下pub_date属性，执照出发布时间在当前时间之前的。

基于上面shell中的测试验证，整理一下`polls/tests.py`里所有的测试：
```python
def create_question(question_text, days):
    """
    Creates a question with the given `question_text` and published the
    given number of `days` offset to now (negative for questions published
    in the past, positive for questions that have yet to be published).
    """
    time = timezone.now() + datetime.timedelta(days=days)
    return Question.objects.create(question_text=question_text, pub_date=time)


class QuestionViewTests(TestCase):
    def test_index_view_with_no_questions(self):
        """
        If no questions exist, an appropriate message should be displayed.
        """
        response = self.client.get(reverse('polls:index'))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "No polls are available.")
        self.assertQuerysetEqual(response.context['latest_question_list'], [])

    def test_index_view_with_a_past_question(self):
        """
        Questions with a pub_date in the past should be displayed on the
        index page.
        """
        create_question(question_text="Past question.", days=-30)
        response = self.client.get(reverse('polls:index'))
        self.assertQuerysetEqual(
            response.context['latest_question_list'],
            ['<Question: Past question.>']
        )

    def test_index_view_with_a_future_question(self):
        """
        Questions with a pub_date in the future should not be displayed on
        the index page.
        """
        create_question(question_text="Future question.", days=30)
        response = self.client.get(reverse('polls:index'))
        self.assertContains(response, "No polls are available.")
        self.assertQuerysetEqual(response.context['latest_question_list'], [])

    def test_index_view_with_future_question_and_past_question(self):
        """
        Even if both past and future questions exist, only past questions
        should be displayed.
        """
        create_question(question_text="Past question.", days=-30)
        create_question(question_text="Future question.", days=30)
        response = self.client.get(reverse('polls:index'))
        self.assertQuerysetEqual(
            response.context['latest_question_list'],
            ['<Question: Past question.>']
        )

    def test_index_view_with_two_past_questions(self):
        """
        The questions index page may display multiple questions.
        """
        create_question(question_text="Past question 1.", days=-30)
        create_question(question_text="Past question 2.", days=-5)
        response = self.client.get(reverse('polls:index'))
        self.assertQuerysetEqual(
            response.context['latest_question_list'],
            ['<Question: Past question 2.>', '<Question: Past question 1.>']
        )
        
    class QuestionIndexDetailTests(TestCase):
        def test_detail_view_with_a_future_question(self):
            """
            The detail view of a question with a pub_date in the future should
            return a 404 not found.
            """
            future_question = create_question(question_text='Future question.', days=5)
            url = reverse('polls:detail', args=(future_question.id,))
            response = self.client.get(url)
            self.assertEqual(response.status_code, 404)
    
        def test_detail_view_with_a_past_question(self):
            """
            The detail view of a question with a pub_date in the past should
            display the question's text.
            """
            past_question = create_question(question_text='Past Question.', days=-5)
            url = reverse('polls:detail', args=(past_question.id,))
            response = self.client.get(url)
            self.assertContains(response, past_question.question_text)
```

更多参考[Testing in Django](https://docs.djangoproject.com/en/1.9/topics/testing/)


#### 打扮一下
**django.contrib.staticfiles**负责项目中的静态文件，例如css, js，jpg啥的。

在polls下创建一个`static`文件夹,其他的位置参看[STATICFILES_FINDERS ](https://docs.djangoproject.com/en/1.9/ref/settings/#std:setting-STATICFILES_FINDERS)。然后跟template一样，在这个`static`下创建`polls/style.css`文件。
```css
li a {
    color: green;
}
```
之后到模板里引入这个css文件
```html
{% load staticfiles %}

<link rel="stylesheet" type="text/css" href="{% static 'polls/style.css' %}" />
```

copy一个背景图片到`polls/static/polls/images/background.gif`。使用相对路径把它加到css中引用：
```css
body {
    background: white url("images/background.gif") no-repeat right bottom;
}
```

更多花哨参见[the static files howto](https://docs.djangoproject.com/en/1.9/howto/static-files/), [the staticfiles reference](https://docs.djangoproject.com/en/1.9/ref/contrib/staticfiles/), [ Deploying static files] (https://docs.djangoproject.com/en/1.9/howto/static-files/deployment/)


#### 打包
重用是python的王道。共用的包可以参见[ The Python Package Index (PyPI) ](https://pypi.python.org/pypi)

必备：[ setuptools](https://pypi.python.org/pypi/setuptools)、[pip](https://pypi.python.org/pypi/pip)

再看一下项目结构
```
mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        wsgi.py
    polls/
        __init__.py
        admin.py
        migrations/
            __init__.py
            0001_initial.py
        models.py
        static/
            polls/
                images/
                    background.gif
                style.css
        templates/
            polls/
                detail.html
                index.html
                results.html
        tests.py
        urls.py
        views.py
    templates/
        admin/
            base_site.html
```

1. 在你的project外为polls创建一个父目录django-polls。
2. 把polls文件夹转移到django-polls
3. 编辑django-polls/README.rst 
4. 创建django-polls/LICENSE 
5. 创建django-polls/setup.py, 参看[setuptools docs](https://setuptools.readthedocs.io/en/latest/),描述构建与安装过程.
```python
import os
from setuptools import find_packages, setup

with open(os.path.join(os.path.dirname(__file__), 'README.rst')) as readme:
    README = readme.read()

# allow setup.py to be run from any path
os.chdir(os.path.normpath(os.path.join(os.path.abspath(__file__), os.pardir)))

setup(
    name='django-polls',
    version='0.1',
    packages=find_packages(),
    include_package_data=True,
    license='BSD License',  # example license
    description='A simple Django app to conduct Web-based polls.',
    long_description=README,
    url='https://www.example.com/',
    author='Your Name',
    author_email='yourname@example.com',
    classifiers=[
        'Environment :: Web Environment',
        'Framework :: Django',
        'Framework :: Django :: X.Y',  # replace "X.Y" as appropriate
        'Intended Audience :: Developers',
        'License :: OSI Approved :: BSD License',  # example license
        'Operating System :: OS Independent',
        'Programming Language :: Python',
        # Replace these appropriately if you are stuck on Python 2.
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.4',
        'Programming Language :: Python :: 3.5',
        'Topic :: Internet :: WWW/HTTP',
        'Topic :: Internet :: WWW/HTTP :: Dynamic Content',
    ],
)
```
6. 默认只打包python的package和module，如果要其他的文件，需要定义在**MANIFEST.in **。比如上面的LICENSE、README.rst之类
```
include LICENSE
include README.rst
recursive-include polls/static *
recursive-include polls/templates *
```
7. 最好能建立一些doc,也放到MANIFEST.in里。django-polls/docs
8. 测试** python setup.py sdist**.回创建一个`dist`文件夹，下面有django-polls-0.1.tar.gz。

[更多打包相关](https://packaging.python.org/en/latest/distributing.html).